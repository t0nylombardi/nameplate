=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/avatar/cache.rb ===
# frozen_string_literal: true

module NamePlate
  class Avatar
    # Builds file paths for cached avatars.
    class Cache
      # Returns the base path for cached avatars.
      #
      # @return [String] Base cache path.
      def self.base_path
        "#{NamePlate.cache_base_path || "public/system"}/nameplate/#{Avatar::VERSION}"
      end

      # Builds the file path for a cached avatar.
      #
      # @param [Identity] identity The identity object representing the user.
      # @param [Integer] size The size of the avatar.
      # @return [String] The file path for the cached avatar.
      def self.path(identity, size)
        dir = File.join(base_path, identity.letters, identity.color.join("_"))
        FileUtils.mkdir_p(dir)
        File.join(dir, "#{size}.png")
      end

      # Check if a cached avatar exists for the given identity and size.
      #
      # @param [Identity] identity The identity object representing the user.
      # @param [Integer] size The size of the avatar.
      # @return [Boolean] True if a cached avatar exists, false otherwise.
      def self.cached?(identity, size)
        File.exist?(path(identity, size))
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/avatar/generator.rb ===
# frozen_string_literal: true

require "mini_magick"

module NamePlate
  class Avatar
    # Generates PNG avatars from usernames using MiniMagick/ImageMagick.
    #
    # - Derives an {Identity} (initial letters + background color) from a username.
    # - Produces a square PNG at the requested size (capped at {Avatar::FULLSIZE}).
    # - Uses {Avatar::Cache} to reuse existing files and to build deterministic paths.
    #
    # The high-level API for consumers is {NamePlate::Avatar.generate}. This class
    # exists as the lower-level, orchestration entry point that handles logging,
    # validation, caching, and MiniMagick invocation.
    #
    # Requirements:
    # - ImageMagick must be installed and accessible on the PATH (MiniMagick uses `convert`).
    # - A valid font file must be configured at {Avatar::FONT_FILE}.
    #
    # Configuration sources used during generation:
    # - `NamePlate.pointsize`, `NamePlate.weight`, `NamePlate.annotate_position`
    # - {Avatar::FILL_COLOR} (foreground text/letters color)
    # - {Avatar::FONT_FILE} (font used by ImageMagick)
    # - `NamePlate.cache_base_path` (root for cached files; see {Avatar::Cache})
    # - `ENV["NAMEPLATE_LOG_LEVEL"]` (set to `DEBUG` for verbose logging)
    #
    # @example Generate and return a cached 128px avatar path
    #   path = NamePlate::Avatar::Generator.call("Tony Baloney", 128)
    #   # => "public/system/nameplate/1/TB/163_163_163/128.png"
    #
    # @example Disable cache and provide a custom logger
    #   logger = Logger.new($stderr)
    #   path = NamePlate::Avatar::Generator.call("Ada Lovelace", 256, cache: false, logger: logger)
    #   # Generates a fresh 256px PNG even if a cached one exists
    #
    # @see NamePlate::Avatar.generate User-facing convenience API
    # @see NamePlate::Avatar::Cache Path building and cache helpers
    class Generator
      # Base class for avatar generation errors
      # @abstract
      # @since 0.1.0
      class GenerationError < StandardError; end

      # Raised when MiniMagick/ImageMagick fails to render an avatar.
      # @since 0.1.0
      class ImageMagickError < GenerationError; end

      # Raised when filesystem operations (write/verify) fail.
      # @since 0.1.0
      class FileSystemError < GenerationError; end

      # Raised when inputs or configuration are invalid.
      # @since 1.0.0
      class ConfigurationError < GenerationError; end

      # Instantiate a new generator.
      #
      # Prefer {::call} unless you need a long-lived instance.
      #
      # @param username [String] The source name used to derive initials and color.
      # @param size [Integer] Target size in pixels (> 0). Capped at {Avatar::FULLSIZE}.
      # @param cache [Boolean] Reuse existing cached PNG when present. Defaults to `true`.
      # @param logger [Logger, nil] Optional logger; defaults to a simple STDOUT logger.
      # @raise [ConfigurationError] If parameters are invalid or required assets are missing.
      def initialize(username, size, cache: true, logger: nil)
        @username = username
        @size = size
        @cache = cache
        @font = Avatar::FONT_FILE
        @fill = Avatar::FILL_COLOR
        @logger = logger || default_logger

        validate_inputs!
      end

      # Convenience entry point that builds, runs, and returns the generated path.
      #
      # @param username [String]
      # @param size [Integer]
      # @param cache [Boolean]
      # @param logger [Logger, nil]
      # @return [String] Filesystem path to the generated PNG.
      # @raise [ConfigurationError] If inputs/configuration are invalid.
      # @raise [ImageMagickError] If MiniMagick/ImageMagick fails to render.
      # @raise [FileSystemError] If the resulting file fails verification.
      # @raise [GenerationError] For other generation-related failures.
      def self.call(username, size, cache: true, logger: nil)
        new(username, size, cache: cache, logger: logger).execute!
      end

      # Run the avatar generation pipeline: build identity, resolve cache path,
      # and generate if needed.
      #
      # @return [String] Path to the generated (or cached) avatar PNG.
      # @raise [ConfigurationError] If inputs/configuration are invalid.
      # @raise [ImageMagickError] If MiniMagick/ImageMagick fails to render.
      # @raise [FileSystemError] Reserved for callers that optionally verify output.
      def execute!
        logger.info "Starting avatar generation for '#{username}' at size #{size}px"
        path = generate
        logger.info "Avatar generation completed successfully: #{path}"
        path
      rescue => e
        logger.error "Avatar generation failed: #{e.class.name} - #{e.message}"
        logger.error "Backtrace: #{e.backtrace.first(5).join("\n")}"
        raise
      end

      private

      attr_reader :username, :size, :cache, :font, :fill, :logger

      # Generate or reuse an avatar at the requested size.
      #
      # Builds an identity from `username`, computes the cache path,
      # renders the PNG if not already cached, and returns the file path.
      #
      # @return [String] Filesystem path to the generated or cached avatar PNG.
      def generate
        identity = build_identity
        target_size = normalize_size
        target_path = Avatar::Cache.path(identity, target_size)

        return use_cached(target_path) if cached?(target_path)

        generate_avatar(identity, target_size, target_path)

        target_path
      end

      # Build an avatar identity from the configured username.
      #
      # @return [NamePlate::Avatar::Identity] Derived initials and background color.
      def build_identity
        Avatar::Identity.from_username(username).tap do |identity|
          logger.debug "Generated identity: #{identity.inspect}"
        end
      end

      # Clamp the requested size to the maximum full size.
      #
      # @return [Integer] Target size in pixels (<= {Avatar::FULLSIZE}).
      def normalize_size
        [size, Avatar::FULLSIZE].min.tap do |s|
          logger.debug "Target size: #{s}"
        end
      end

      # Check if a cached avatar exists at the given path.
      #
      # @param [String] path The expected avatar file path.
      # @return [Boolean] True if a cached file exists, false otherwise.
      def cached?(path)
        cache && File.exist?(path)
      end

      # Use an existing cached avatar path.
      #
      # @param [String] path The cached avatar file path.
      # @return [String] The same cached path that was provided.
      def use_cached(path)
        logger.info "Using cached avatar: #{path}"
        path
      end

      # Render the avatar image using MiniMagick/ImageMagick.
      #
      # @param identity [Identity] Letters and background color.
      # @param size [Integer] Target size in pixels.
      # @param filename [String, Pathname] Output file path.
      # @raise [ImageMagickError] If MiniMagick raises during conversion.
      def generate_avatar(identity, size, filename)
        MiniMagick.convert do |c|
          c.size "#{size}x#{size}"
          c << "xc:#{to_rgb(identity.color)}"
          c.pointsize NamePlate.pointsize.to_s
          c.font font.to_s
          c.weight NamePlate.weight.to_s
          c.fill fill.to_s.gsub(/\s+/, "")
          c.gravity "Center"
          c.annotate NamePlate.annotate_position.to_s, identity.letters.to_s
          c << filename.to_s
        end
      rescue => e
        raise ImageMagickError, "MiniMagick failed to generate avatar: #{e.message}"
      end

      # Convert `[r, g, b]` array to `rgb(r,g,b)` string accepted by ImageMagick.
      #
      # @param color [Array<Integer>] RGB values in the 0..255 range.
      # @return [String] `rgb(r,g,b)` formatted string.
      # @raise [ConfigurationError] If the color is not a valid triplet.
      def to_rgb(color)
        "rgb(#{color.join(",")})"
      rescue => e
        raise ConfigurationError, "Invalid color format: #{color.inspect} - #{e.message}"
      end

      # Validate constructor inputs and required configuration.
      #
      # @return [void]
      # @raise [ConfigurationError] When any validation fails.
      def validate_inputs!
        raise ConfigurationError, "Username cannot be empty" if username.to_s.strip.empty?
        raise ConfigurationError, "Size must be positive integer" unless size.is_a?(Integer) && size.positive?
        raise ConfigurationError, "Font file not found: #{font}" unless File.exist?(font.to_s)
        raise ConfigurationError, "Fill color not configured" if fill.to_s.empty?
      end

      # Build a default logger that writes to STDOUT.
      #
      # Log level defaults to `INFO`; set `ENV["NAMEPLATE_LOG_LEVEL"] = "DEBUG"`
      # to enable verbose output during generation.
      #
      # @return [Logger]
      def default_logger
        require "logger"
        Logger.new($stdout).tap do |log|
          log.level = (ENV["NAMEPLATE_LOG_LEVEL"]&.upcase == "DEBUG") ? Logger::DEBUG : Logger::INFO
          log.formatter = proc do |severity, datetime, _progname, msg|
            "[#{datetime.strftime("%H:%M:%S")}] #{severity}: #{msg}\n"
          end
        end
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/avatar/identity.rb ===
# frozen_string_literal: true

module NamePlate
  class Avatar
    # Represents a derived avatar identity: letters and color.
    class Identity
      attr_reader :color, :letters

      def initialize(color, letters)
        @color = color
        @letters = letters
      end

      # Build an identity from a username.
      #
      # @param [String] username The input name.
      # @return [Identity] The derived avatar identity.
      def self.from_username(username)
        color = NamePlate::Colors.for(username)
        letters = initials(username, count(username))
        new(color, letters)
      end

      class << self
        private

        def initials(username, count)
          username
            .split(/\s+/)
            .map { |word| word[0] }
            .join
            .upcase[0..count - 1]
        end

        def count(username)
          (username.strip.split(/\s+/).size >= 2) ? 2 : 1
        end
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/avatar.rb ===
# frozen_string_literal: true

require "fileutils"
require_relative "avatar/generator"
require_relative "avatar/cache"
require_relative "avatar/identity"

module NamePlate
  # Avatar generation from usernames.
  #
  # Responsibilities are split into:
  # - {Identity}: maps username â†’ initials + color
  # - {Cache}: builds consistent cache paths
  # - {Generator}: orchestrates avatar creation and resizing
  #
  # Public API:
  #   NamePlate::Avatar.generate("John Doe", 128)
  #
  class Avatar
    VERSION = 1 # bump on any change to avatar generation
    FULLSIZE = 600
    FILL_COLOR = "rgba(255, 255, 255, 0.65)" # white at 65% opacity
    # Use __dir__ and fall back to the current working directory for Steep
    # which can type __dir__ as String | nil.
    FONT_FILE = File.expand_path("fonts/Roboto-Medium", __dir__ || Dir.pwd)

    # Public API entry point
    #
    # @param username [String]
    # @param size [Integer]
    # @param opts [Hash] options, e.g. { cache: true }
    # @return [String] path to avatar file
    def self.generate(username, size, opts = {})
      Generator.call(username, size, **opts)
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/colors/palette.rb ===
# frozen_string_literal: true

require "digest"

module NamePlate
  module Colors
    class Palette
      attr_reader :colors

      # Allow zero-arg construction for the registry
      def initialize(colors = nil)
        colors ||= self.class.const_get(:COLORS)
        @colors = colors.freeze
      end

      def self.key
        raise NotImplementedError, "#{self}.key must return a Symbol"
      end

      # Select a color based on a username string.
      #
      # @param [String] username The username to base the color selection on.
      # @return [Array<Integer>] RGB triplet
      def pick(username)
        index = hash_index(username)
        colors[index % colors.length]
      end

      private

      # Generate a hash index from a username.
      #
      # @param [String] username The username to hash.
      # @return [Integer] The hash index.
      def hash_index(username)
        Digest::MD5.hexdigest(username)[0...15].to_i(16)
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/colors/palettes/custom.rb ===
# frozen_string_literal: true

module NamePlate
  module Colors
    module Palettes
      class Custom < Palette
        def self.key = :custom

        def initialize
          super(NamePlate.custom_palette || [])
        end

        def pick(username)
          raise "Custom palette not set" if colors.empty?
          super
        end
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/colors/palettes/dracula.rb ===
# frozen_string_literal: true

module NamePlate
  module Colors
    module Palettes
      # Inspired by Dracula theme
      class Dracula < Palette
        COLORS = [
          [40, 42, 54],    # background
          [68, 71, 90],    # current line
          [98, 114, 164],  # comment
          [139, 233, 253], # cyan
          [80, 250, 123],  # green
          [255, 184, 108], # orange
          [255, 121, 198], # pink
          [189, 147, 249], # purple
          [241, 250, 140], # yellow
          [255, 85, 85]    # red
        ].freeze

        def self.key = :dracula

        def initialize
          super(COLORS)
        end
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/colors/palettes/google.rb ===
# frozen_string_literal: true

module NamePlate
  module Colors
    module Palettes
      class Google < Palette
        GOOGLE_COLORS = [
          [226, 95, 81], # A
          [242, 96, 145], # B
          [187, 101, 202], # C
          [149, 114, 207], # D
          [120, 132, 205], # E
          [91, 149, 249], # F
          [72, 194, 249], # G
          [69, 208, 226], # H
          [72, 182, 172], # I
          [82, 188, 137], # J
          [155, 206, 95], # K
          [212, 227, 74], # L
          [254, 218, 16], # M
          [247, 192, 0], # N
          [255, 168, 0], # O
          [255, 138, 96], # P
          [194, 194, 194], # Q
          [143, 164, 175], # R
          [162, 136, 126], # S
          [163, 163, 163], # T
          [175, 181, 226], # U
          [179, 155, 221], # V
          [194, 194, 194], # W
          [124, 222, 235], # X
          [188, 170, 164], # Y
          [173, 214, 125] # Z
        ].freeze

        def self.key = :google

        def initialize
          super(GOOGLE_COLORS)
        end

        def pick(username)
          char = username[0].upcase
          if /[A-Z]/.match?(char)
            colors[char.ord - 65]
          elsif /[0-9]/.match?(char)
            colors[char.to_i]
          else
            super
          end
        end
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/colors/palettes/iwanthue.rb ===
# frozen_string_literal: true

module NamePlate
  module Colors
    module Palettes
      class Iwanthue < Palette
        IWANTHUE_COLORS = [
          [198, 125, 40],
          [61, 155, 243],
          [74, 243, 75],
          [238, 89, 166],
          [52, 240, 224],
          [177, 156, 155],
          [240, 120, 145],
          [111, 154, 78],
          [237, 179, 245],
          [237, 101, 95],
          [89, 239, 155],
          [43, 254, 70],
          [163, 212, 245],
          [65, 152, 142],
          [165, 135, 246],
          [181, 166, 38],
          [187, 229, 206],
          [77, 164, 25],
          [179, 246, 101],
          [234, 93, 37],
          [225, 155, 115],
          [142, 140, 188],
          [223, 120, 140],
          [249, 174, 27],
          [244, 117, 225],
          [137, 141, 102],
          [75, 191, 146],
          [188, 239, 142],
          [164, 199, 145],
          [173, 120, 149],
          [59, 195, 89],
          [222, 198, 220],
          [68, 145, 187],
          [236, 204, 179],
          [159, 195, 72],
          [188, 121, 189],
          [166, 160, 85],
          [181, 233, 37],
          [236, 177, 85],
          [121, 147, 160],
          [234, 218, 110],
          [241, 157, 191],
          [62, 200, 234],
          [133, 243, 34],
          [88, 149, 110],
          [59, 228, 248],
          [183, 119, 118],
          [251, 195, 45],
          [113, 196, 122],
          [197, 115, 70],
          [80, 175, 187],
          [103, 231, 238],
          [240, 72, 133],
          [228, 149, 241],
          [180, 188, 159],
          [172, 132, 85],
          [180, 135, 251],
          [236, 194, 58],
          [217, 176, 109],
          [88, 244, 199],
          [186, 157, 239],
          [113, 230, 96],
          [206, 115, 165],
          [244, 178, 163],
          [230, 139, 26],
          [241, 125, 89],
          [83, 160, 66],
          [107, 190, 166],
          [197, 161, 210],
          [198, 203, 245],
          [238, 117, 19],
          [228, 119, 116],
          [131, 156, 41],
          [145, 178, 168],
          [139, 170, 220],
          [233, 95, 125],
          [87, 178, 230],
          [157, 200, 119],
          [237, 140, 76],
          [229, 185, 186],
          [144, 206, 212],
          [236, 209, 158],
          [185, 189, 79],
          [34, 208, 66],
          [84, 238, 129],
          [133, 140, 134],
          [67, 157, 94],
          [168, 179, 25],
          [140, 145, 240],
          [151, 241, 125],
          [67, 162, 107],
          [200, 156, 21],
          [169, 173, 189],
          [226, 116, 189],
          [133, 231, 191],
          [194, 161, 63],
          [241, 77, 99],
          [241, 217, 53],
          [123, 204, 105],
          [210, 201, 119],
          [229, 108, 155],
          [240, 91, 72],
          [187, 115, 210],
          [240, 163, 100],
          [178, 217, 57],
          [179, 135, 116],
          [204, 211, 24],
          [186, 135, 57],
          [223, 176, 135],
          [204, 148, 151],
          [116, 223, 50],
          [95, 195, 46],
          [123, 160, 236],
          [181, 172, 131],
          [142, 220, 202],
          [240, 140, 112],
          [172, 145, 164],
          [228, 124, 45],
          [135, 151, 243],
          [42, 205, 125],
          [192, 233, 116],
          [119, 170, 114],
          [158, 138, 26],
          [73, 190, 183],
          [185, 229, 243],
          [227, 107, 55],
          [196, 205, 202],
          [132, 143, 60],
          [233, 192, 237],
          [62, 150, 220],
          [205, 201, 141],
          [106, 140, 190],
          [161, 131, 205],
          [135, 134, 158],
          [198, 139, 81],
          [115, 171, 32],
          [101, 181, 67],
          [149, 137, 119],
          [37, 142, 183],
          [183, 130, 175],
          [168, 125, 133],
          [124, 142, 87],
          [236, 156, 171],
          [232, 194, 91],
          [219, 200, 69],
          [144, 219, 34],
          [219, 95, 187],
          [145, 154, 217],
          [165, 185, 100],
          [127, 238, 163],
          [224, 178, 198],
          [119, 153, 120],
          [124, 212, 92],
          [172, 161, 105],
          [231, 155, 135],
          [157, 132, 101],
          [122, 185, 146],
          [53, 166, 51],
          [70, 163, 90],
          [150, 190, 213],
          [210, 107, 60],
          [166, 152, 185],
          [159, 194, 159],
          [39, 141, 222],
          [202, 176, 161],
          [95, 140, 229],
          [168, 142, 87],
          [93, 170, 203],
          [159, 142, 54],
          [14, 168, 39],
          [94, 150, 149],
          [187, 206, 136],
          [157, 224, 166],
          [235, 158, 208],
          [109, 232, 216],
          [141, 201, 87],
          [208, 124, 118],
          [142, 125, 214],
          [19, 237, 174],
          [72, 219, 41],
          [234, 102, 111],
          [168, 142, 79],
          [188, 135, 35],
          [95, 155, 143],
          [148, 173, 116],
          [223, 112, 95],
          [228, 128, 236],
          [206, 114, 54],
          [195, 119, 88],
          [235, 140, 94],
          [235, 202, 125],
          [233, 155, 153],
          [214, 214, 238],
          [246, 200, 35],
          [151, 125, 171],
          [132, 145, 172],
          [131, 142, 118],
          [199, 126, 150],
          [61, 162, 123],
          [58, 176, 151],
          [215, 141, 69],
          [225, 154, 220],
          [220, 77, 167],
          [233, 161, 64],
          [130, 221, 137],
          [81, 191, 129],
          [169, 162, 140],
          [174, 177, 222],
          [236, 174, 47],
          [233, 188, 180],
          [69, 222, 172],
          [71, 232, 93],
          [118, 211, 238],
          [157, 224, 83],
          [218, 105, 73],
          [126, 169, 36]
        ].freeze

        def self.key = :iwanthue

        def initialize
          super(IWANTHUE_COLORS)
        end
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/colors/palettes/jedi_light.rb ===
# frozen_string_literal: true

module NamePlate
  module Colors
    module Palettes
      # A "light side" Jedi-inspired palette
      class JediLight < Palette
        COLORS = [
          [255, 255, 255], # pure white
          [0, 87, 183],    # Jedi blue
          [114, 137, 218], # softer blue
          [0, 204, 255],   # cyan/saber glow
          [255, 214, 10],  # light yellow/gold
          [173, 216, 230], # pale blue
          [192, 192, 192]  # silver
        ].freeze

        def self.key = :jedi_light

        def initialize
          super(COLORS)
        end
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/colors/palettes/monokai.rb ===
# frozen_string_literal: true

module NamePlate
  module Colors
    module Palettes
      # Inspired by Monokai theme
      class Monokai < Palette
        COLORS = [
          [39, 40, 34],    # background
          [248, 248, 242], # foreground
          [249, 38, 114],  # pink
          [166, 226, 46],  # green
          [253, 151, 31],  # orange
          [102, 217, 239], # cyan
          [174, 129, 255], # purple
          [230, 219, 116]  # yellow
        ].freeze

        def self.key = :monokai

        def initialize
          super(COLORS)
        end
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/colors/palettes/pastel.rb ===
# frozen_string_literal: true

module NamePlate
  module Colors
    module Palettes
      # A soft pastel theme
      class Pastel < Palette
        COLORS = [
          [255, 179, 186], # light pink
          [255, 223, 186], # peach
          [255, 255, 186], # light yellow
          [186, 255, 201], # mint
          [186, 225, 255]  # baby blue
        ].freeze

        def self.key = :pastel

        def initialize
          super(COLORS)
        end
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/colors.rb ===
# frozen_string_literal: true

require_relative "colors/palette"

# Auto-require all palette classes
Dir[File.join(__dir__ || Dir.pwd, "colors", "palettes", "*.rb")].sort.each { |f| require f }

module NamePlate
  module Colors
    # Lazily build registry from all subclasses of Palette
    def self.registry
      @registry ||= Palettes.constants.map do |const|
        klass = Palettes.const_get(const)
        # @type var klass: NamePlate::Colors::_PaletteClass

        next unless klass.is_a?(Class) && klass < Palette
        [klass.key, klass.new]
      end.compact.to_h.freeze
    end

    def self.for(username)
      palette = registry.fetch(NamePlate.colors_palette) do
        raise ArgumentError, "Unknown palette: #{NamePlate.colors_palette}"
      end
      palette.pick(username)
    end

    # Validate a custom palette of colors.
    #
    # @param [Array[Integer]] palette The custom palette of colors.
    # @return [Boolean] Whether the custom palette is valid.
    def self.valid_custom_palette?(palette)
      return false if palette.nil?
      return false unless palette.is_a?(Array)
      return false unless palette.all? { |c| c.is_a?(String) && c.match?(/\A#(?:[0-9a-fA-F]{3}){1,2}\z/) }
      return false if palette.size < 2
      return false if palette.size > 20
      true
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/configuration.rb ===
# frozen_string_literal: true

module NamePlate
  module Configuration
    def cache_base_path
      @cache_base_path
    end

    def cache_base_path=(v)
      @cache_base_path = v
    end

    def font
      @font || Avatar::FONT_FILE
    end

    def font=(v)
      @font = v
    end

    def fill_color
      @fill_color || Avatar::FILL_COLOR
    end

    def fill_color=(v)
      @fill_color = v
    end

    def colors_palette
      @colors_palette ||= :google
    end

    def colors_palette=(v)
      @colors_palette = v if Colors::Palette.include?(v)
    end

    def custom_palette
      @custom_palette ||= nil
    end

    # Set a custom palette of colors to use when colors_palette is :custom
    #
    # @param [Array[Integer]] v The custom palette of colors.
    # @return [Array[Integer]] The custom palette of colors.
    def custom_palette=(v)
      @custom_palette = v
      if @custom_palette.nil? && @colors_palette == :custom
        raise "Missing Custom Palette, please set config.custom_palette if using :custom"
      end
      if Colors.valid_custom_palette?(@custom_palette)
        raise "Invalid Custom Palette, please update config.custom_palette"
      end
    end

    def weight
      @weight ||= 300
    end

    def weight=(v)
      @weight = v
    end

    def annotate_position
      @annotate_position ||= "-0+5"
    end

    def annotate_position=(v)
      @annotate_position = v
    end

    def letters_count
      @letters_count ||= 1
    end

    def letters_count=(v)
      @letters_count = v
    end

    def pointsize
      @pointsize ||= 140
    end

    def pointsize=(v)
      @pointsize = v
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/errors.rb ===


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/has_avatar.rb ===
# frozen_string_literal: true

module NamePlate
  # Mixin for models that "have an avatar".
  #
  # Example:
  #   class User
  #     include NamePlate::HasAvatar
  #     attr_accessor :name
  #   end
  #
  #   user = User.new.tap { |u| u.name = "Tony" }
  #   user.avatar_path(128)
  #   # => "public/system/nameplate/2/T/226_95_81/128.png"
  #
  module HasAvatar
    # Return the filesystem path to the generated avatar
    #
    # @param size [Integer] size in px (default 64)
    # @return [String] path to avatar image
    def avatar_path(size = 64)
      NamePlate::Avatar.generate(username, size)
    end

    # Return the URL path to the generated avatar
    #
    # @param size [Integer] size in px (default 64)
    # @return [String] URL for avatar image
    def avatar_url(size = 64)
      NamePlate.path_to_url(avatar_path(size))
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/image/resizer.rb ===
# frozen_string_literal: true

require "mini_magick"

module NamePlate
  module Image
    # Resizes images with MiniMagick.
    #
    # Responsibility: take a source image and produce a resized
    # version that fits the requested WxH, centered, with transparent padding.
    #
    # Used by {Avatar::Generator} when a non-fullsize avatar is requested.
    class Resizer
      # Entry point to resize an image.
      #
      # @param from [String] path to the source image file
      # @param to [String] path to the destination image file
      # @param width [Integer] target width in pixels
      # @param height [Integer] target height in pixels
      # @return [NamePlate::Results::SuccessResult, NamePlate::Results::FailureResult]
      def resize(from:, to:, width:, height:)
        validate_inputs!(from: from, to: to, width: width, height: height)

        process_resize(from: from, to: to, width: width, height: height)
      rescue => e
        failure_result(e, from: from, to: to, width: width, height: height)
      end

      private

      # ------------------------------
      # Validation
      # ------------------------------

      def validate_inputs!(from:, to:, width:, height:)
        raise ArgumentError, "Source file not found: #{from}" unless File.exist?(from)
        raise ArgumentError, "Width must be positive integer" unless width.is_a?(Integer) && width.positive?
        raise ArgumentError, "Height must be positive integer" unless height.is_a?(Integer) && height.positive?
        raise ArgumentError, "Destination path cannot be empty" if to.to_s.strip.empty?
      end

      # ------------------------------
      # Processing
      # ------------------------------

      def process_resize(from:, to:, width:, height:)
        image = MiniMagick::Image.open(from)

        image.combine_options do |c|
          c.background "transparent"
          c.gravity "center"
          c.thumbnail "#{width}x#{height}^"
          c.extent "#{width}x#{height}"
          c.unsharp "2x0.5+0.7+0"
          c.quality 98
        end

        image.write(to)
        success_result(to)
      end

      # ------------------------------
      # Result builders
      # ------------------------------

      def success_result(path)
        NamePlate::Results::SuccessResult.new(value: { path: path })
      end

      def failure_result(exception, from:, to:, width:, height:)
        NamePlate::Results::FailureResult.new(
          error: {
            message: "Image resize failed: #{exception.message}",
            exception: exception,
            from: from,
            to: to,
            width: width,
            height: height
          }
        )
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/results/failure_result.rb ===
# frozen_string_literal: true

module NamePlate
  module Results
    # Represents a failed operation result.
    #
    # Provides a consistent API for checking failure
    # and accessing error details.
    class FailureResult
      attr_reader :error

      def initialize(error:)
        @error = error
      end

      # @return [Boolean]
      def success?
        false
      end

      # @return [Boolean]
      def failure(argv, stdout, stderr, status)
        NamePlate::Results::FailureResult.new(
          error: {
            message: "Command failed",
            argv: argv,
            stdout: stdout,
            stderr: stderr,
            status: status
          }
        )
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/results/success_result.rb ===
# frozen_string_literal: true

module NamePlate
  module Results
    # Represents a successful operation result.
    #
    # Provides a consistent API for checking success
    # and accessing the returned value.
    class SuccessResult
      attr_reader :value

      def initialize(value:)
        @value = value
      end

      # @return [Boolean]
      def success?
        true
      end

      # @return [Boolean]
      def failure?
        false
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/shell/command_runner.rb ===
# frozen_string_literal: true

require "open3"

module NamePlate
  module Shell
    # Runs external commands with explicit argument arrays (no shell eval).
    # Single Responsibility: Execute a command and capture outputs.
    #
    # Returns SuccessResult or FailureResult with stdout/stderr/status.
    class CommandRunner
      # Execute a command safely.
      #
      # @param argv [Array<String>] the command and its arguments
      # @return [NamePlate::Results::SuccessResult, NamePlate::Results::FailureResult]
      def run(argv)
        validate_argv!(argv)

        stdout, stderr, status = Open3.capture3(*argv)
        puts "Command stdout: #{stdout.inspect}"
        puts "Command stderr: #{stderr.inspect}"
        puts "Command status: #{status.inspect}"
        if status.success? && stderr.to_s.strip.empty?
          success_result(stdout: stdout, status: status)
        else
          failure_result(argv: argv, stdout: stdout, stderr: stderr, status: status)
          puts "Command failed: #{stderr.inspect}"
        end
      rescue => e
        failure_result(exception: e)
      end

      private

      def validate_argv!(argv)
        return if argv.is_a?(Array) && argv.all? { |a| a.is_a?(String) && !a.empty? }
        raise ArgumentError, "argv must be a non-empty Array<String>"
      end

      def success_result(stdout:, status:)
        NamePlate::Results::SuccessResult.new(value: {stdout: stdout, status: status})
      end

      def failure_result(argv: nil, stdout: nil, stderr: nil, status: nil, exception: nil)
        NamePlate::Results::FailureResult.new(
          error: {
            message: exception ? exception.message : "Command failed",
            argv: argv,
            stdout: stdout,
            stderr: stderr,
            status: status,
            exception: exception
          }.compact
        )
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/utils/path_helper.rb ===
module Utils
  module PathHelper
    module_function

    # Convert a public file-system path to a URL path.
    #
    # @param path [String, Pathname]
    # @return [String]
    #
    # Examples:
    #   PathHelper.path_to_url("public/avatars/a.png") #=> "/avatars/a.png"
    def path_to_url(path)
      path.to_s.sub(%r{\Apublic/}, "/")
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/version.rb ===
# frozen_string_literal: true

module NamePlate
  VERSION = "0.1.0".freeze
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate/view_helpers/avatar.rb ===
# frozen_string_literal: true

require "action_view"
require "action_view/helpers"

module NamePlate
  module ViewHelpers
    # Rails view helpers for rendering avatars in controllers/views.
    #
    # Usage in Rails:
    #   include NamePlate::ViewHelpers::Avatar
    #
    # Then in your views:
    #   letter_avatar_for("Tony", 200)
    #   letter_avatar_url("Tony", 200)
    #   letter_avatar_tag("Tony", 200, class: "avatar")
    module Avatar
      if defined?(ActionView::Helpers::AssetTagHelper)
        include ActionView::Helpers::AssetTagHelper
      end

      # Return path to generated avatar image
      #
      # @param name [String] the name to base avatar on
      # @param size [Integer] requested size in px
      # @return [String] filesystem path
      def letter_avatar_for(name, size = 64)
        NamePlate::Avatar.generate(name, size)
      end

      # Return URL for generated avatar image
      #
      # @param name [String] the name to base avatar on
      # @param size [Integer] requested size in px
      # @return [String] URL path
      def letter_avatar_url(name, size = 64)
        NamePlate.path_to_url(letter_avatar_for(name, size))
      end

      # Render an <img> tag for the avatar
      #
      # @param name [String] the name to base avatar on
      # @param size [Integer] requested size
      # @param options [Hash] HTML options (e.g., :class)
      # @return [String] HTML img tag
      def letter_avatar_tag(name, size = 64, options = {})
        src = letter_avatar_url(name, size)

        if defined?(ActionView::Helpers::AssetTagHelper)
          extend ActionView::Helpers::AssetTagHelper
          image_tag(src, options.merge(alt: name))
        else
          class_attr = options.fetch(:class, nil)
          class_str = class_attr ? %( class="#{class_attr}") : ""
          %(<img alt="#{name}"#{class_str} src="#{src}" />)
        end
      end
    end
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/lib/nameplate.rb ===
# frozen_string_literal: true

# stdlib dependencies used internally
require "open3"
require_relative "nameplate/version"
require_relative "nameplate/configuration"
require_relative "nameplate/errors"
require_relative "nameplate/results/success_result"
require_relative "nameplate/results/failure_result"
require_relative "nameplate/avatar"
require_relative "nameplate/colors"
require_relative "nameplate/has_avatar"
require_relative "nameplate/image/resizer"
require_relative "nameplate/shell/command_runner"
require_relative "nameplate/utils/path_helper"
require_relative "nameplate/view_helpers/avatar"

module NamePlate
  extend NamePlate::Configuration

  # Setup DSL for configuration
  #
  # Example:
  #   NamePlate.setup do |config|
  #     config.cache_base_path = "public/system"
  #     config.colors_palette  = :dracula
  #   end
  def self.setup
    yield(self)
  end

  # Public API: generate avatar for a given username
  #
  # @param username [String]
  # @param size [Integer]
  # @return [String] path to generated avatar
  def self.generate(username, size)
    Avatar.generate(username, size)
  end

  # Resize an image and return a structured result
  #
  # @param from [String] source path
  # @param to [String] destination path
  # @param width [Integer]
  # @param height [Integer]
  # @return [SuccessResult, FailureResult]
  def self.resize_image(from:, to:, width:, height:)
    Image::Resizer.new.resize(from: from, to: to, width: width, height: height)
  end

  # Legacy API: returns true/false instead of Result
  #
  # @deprecated prefer {resize_image}
  def self.resize(from, to, width, height)
    resize_image(from: from, to: to, width: width, height: height).success?
  end

  # Convert a filesystem path to a URL
  #
  # @param path [String, Pathname]
  # @return [String]
  def self.path_to_url(path)
    Utils::PathHelper.path_to_url(path)
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/spec/nameplate_spec.rb ===
# frozen_string_literal: true

RSpec.describe NamePlate do
  it "has a version number" do
    expect(NamePlate::VERSION).not_to be nil
  end

  it "does something useful" do
    expect(false).to eq(true)
  end
end


=== /Users/t0nylombardi/dev/t0nylombardi/ruby/nameplate/spec/spec_helper.rb ===
# frozen_string_literal: true

require "nameplate"

RSpec.configure do |config|
  # Enable flags like --only-failures and --next-failure
  config.example_status_persistence_file_path = ".rspec_status"

  # Disable RSpec exposing methods globally on `Module` and `main`
  config.disable_monkey_patching!

  config.expect_with :rspec do |c|
    c.syntax = :expect
  end
end

